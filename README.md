## Advanced Lane Finding

### Author : Sandeep Patil
[//]: # (Image References)

[chess_board_with_detected_corners]: ./sample_images/chess_board_with_detected_corners.png  "chess_board_with_detected_corners"
[curve_lane1]: ./sample_images/curve_lane1.png  "curve_lane1"
[curve_lane2]: ./sample_images/curve_lane2.png  "curve_lane2"
[demo]: ./sample_images/demo.gif  "demo"
[final_image]: ./sample_images/final_image.png  "final_image"
[histogram]: ./sample_images/histogram.png  "histogram"
[image_with_lane]: ./sample_images/image_with_lane.png  "image_with_lane"
[lane_detected]: ./sample_images/lane_detected.png  "lane_detected"
[lane_detected1]: ./sample_images/lane_detected1.png  "lane_detected1"
[lane_lines]: ./sample_images/lane_lines.png  "lane_lines"
[prespective_trasnform1]: ./sample_images/prespective_trasnform1.png  "prespective_trasnform1"
[prespective_trasnform2]: ./sample_images/prespective_trasnform2.png  "prespective_trasnform2"
[sliding_window]: ./sample_images/sliding_window.png  "sliding_window"
[thresholding]: ./sample_images/thresholding.png  "thresholding"
[undistorted]: ./sample_images/undistorted.png  "undistorted"
[undistorted_road]: ./sample_images/undistorted_road.png  "undistorted_road"
[color-fit-lines]: ./sample_images/color-fit-lines.jpg  "color-fit-lines"
[curve_equation]: ./sample_images/curve_equation.jpg  "curve_equation"


[image1]: ./examples/undistort_output.png "Undistorted"
[image2]: ./test_images/test1.jpg "Road Transformed"
[image3]: ./examples/binary_combo_example.jpg "Binary Example"
[image4]: ./examples/warped_straight_lines.jpg "Warp Example"
[image5]: ./examples/color_fit_lines.jpg "Fit Visual"
[image6]: ./examples/example_output.jpg "Output"
[video1]: ./project_video.mp4 "Video"

## Overview
When we drive, we use our eyes to decide where to go.  The lines on the road that show us where the lanes are act as our constant reference for where to steer the vehicle.  Naturally, one of the first things we would like to do in developing a self-driving car is to automatically detect lane lines using an algorithm.
In this project I have tried to detect lane lines in images using Computer vision techniques using Python and OpenCV.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![demo][demo]

The goals / steps of this project are the following:

* Compute the camera calibration matrix and distortion coefficients given a set of chessboard images.
* Apply a distortion correction to raw images.
* Use color transforms, gradients, etc., to create a threshold binary image.
* Apply a perspective transform to rectify binary image ("birds-eye view").
* Detect lane pixels and fit to find the lane boundary.
* Determine the curvature of the lane and vehicle position with respect to center.
* Warp the detected lane boundaries back onto the original image.
* Output visual display of the lane boundaries and numerical estimation of lane curvature and vehicle position.

## Camera calibration and image un distortion.
Sometimes images generated by cameras are distorted due to use of lenses. The distortion mostly happens at edges of image. And before preforming any process on images we need to undistort each image.
To undistort image, we need matrices which defines distortion produced by camera. To get this we need to calibrate camera. 
Following are steps to calibrate camera.
1. Take sample images of chessboard provided by camera.
2. Use cv.findChessboardCorners() method to find corners of chessboard in image.
3. Use cv2.calibrateCamera() method to map object space and images space (corner coordinates). This method return matix that can be used to undistort images.
![chess_board_with_detected_corners][chess_board_with_detected_corners]
4. Undistort image with cv2.undistort() method. Following is undistorted chessboard and road image.

![undistorted][undistorted]
![undistorted_road][undistorted_road]

## Find edges to detect lanes in road. 
Next step after undistorting image is to find edges in images so that we can detect lanes lines in images.
I have used following techniques to find edges of road lane.
1. Convert image to HLS color space. and apply filters on s channel and l channel. 
   * S channel filtering helps to detect lanes clearly in most of patches of road.
   * L channel filtering helps to detect lanes in particular light condition and eliminate edges due to shadows.
   * I have combined results of S and L filters (& operation).
2. Convert image to gray scale and apply X Sobel filter to get edges that are mostly vertical as lane would be appearing vertical in most of cases. 
3. I have taken edges for further processing if it passes either SL filtering or Sobel x filtering.

Following is sample of combination of S&L filtering and Sobel x filtering. In middle image we can see that edges in blue are detected by combination of l and s channels.
And green edges detected by Sobel x filtering. The black and white image is binary image and its combination of all 3 filters. We can see that there is clear cut detection of lane lines. 
![thresholding][thresholding]

## Perspective transformation.
Next step is to detect lane and find curvature of lanes. For this we need to look images in bird eye view. 
To do perspective transformation I have manually identified source and destination points. I have used following source and destination points in image.  

| Source        | Destination   | 
|:-------------:|:-------------:| 
|  265, 675     |  265, 675     | 
| 1030, 675     | 1030, 675     |
|  540, 490     |  265, 150     |
|  749, 490     | 1030, 150     |

Following images show source and destination points transformation for straight road. 

| Source        | Destination   | 
|:-------------:|:-------------:| 
|![prespective_trasnform1][prespective_trasnform1] | ![prespective_trasnform2][prespective_trasnform2]|


Following is sample of bird eye view of edges found for curve lanes. 

| Source        | Edges in bird eye view  | 
|:-------------:|:-------------:| 
|![curve_lane1][curve_lane1] | ![curve_lane2][curve_lane2] |

## Detect pixels corresponding to lane lines.
Next step is to find pixels corresponding to lane lines; for this I have applied following approach.
1. First get frequency of number of pixels across x axis. At lane positions the frequency would be high. So that we can start finding lane pixels from peak points of frequencies.
In following image we can see 2 peaks in histogram for lane lines.
![histogram][histogram]
2. Starting from bottom of image, around these starting positions [peaks], create 2 virtual boxes in two halves of images (Windows)
3. Collect x and y coordinates of pixel within boxes. And slide windows up to next level. Repeate this till we reach to top of image. 
In following image, we can see colored lane points and windows bounding them. The other points (white points) not get included in further calculations. 
![sliding_window][sliding_window]

## Fit poly line for lane lines
1. Next step is to find poly line which would fit to these pixel coordinates. np.polyfit() helps to get coefficients of polyline.
![color-fit-lines][color-fit-lines]
2. Then using polyline equation get values of x coordinate for all values of y.
![lane_lines][lane_lines]
3. Then draw poly lines (yellow) and highligh lane section (green) on image using cv2.fillPoly() function.
![lane_detected][lane_detected]


## Change perspective from bird eye view to normal view
1. Change perspective of binary image from bird eye view to normal view (un warp).
![lane_detected1][lane_detected1]
2. Then merge above image with original image to get images with lanes marked. 
![image_with_lane][image_with_lane]

## Find radius of curvature  
1. As we have polynomial equation of lane lines we can get radius of curvature of poly line using following equation.
![curve_equation][curve_equation]

## Find position of vehicle w.r.t lanes. 

1. As we have polynomial equation we can get position of lanes near to vehicle (where y is max).
And assuming camera is fit at center of vehicle we get center of vehicle at center of image. 
Following eauation gives center of lane.


    center_of_lane = (x_coordinate_of_left_lane + x_coordinate_of_right_lane )/2

    
Vehicle position w.r.t. center would be 

    vehicle_postion = center_corinate_of_vehicle - center_of_lane.

    
For all above calculation we need scale numbers in images space to world space with following factor.

    meters per pixel in y dimension = 30/720 
    meters per pixel in x dimension = 3.7/700  

Following is final processed image.

![final_image][final_image]

## Video pipeline.
The final step is to create pipe line of code to process images in the video.
You can find view sample video  [here](https://github.com/sandysap22/advance_lane_finding/blob/master/project_video_output.mp4) 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![demo][demo]

## Challenges faced. 
When I started I found that lane lines get disturbed by following factors. 
1. On white patch of road at distant portion, the lanes is not visible (to eye also) and if edges of road barrier influence more in these position then detected lane line tends to go out of way. The solution is to reduce area of interest during perspective transformation.
2. Shadow portion : some times Sobel x and s channel filters detects shadow as edges of some objects that creates problem. So I have added additional filter of lightness channel. 
       
## Areas of improvement. 
1. If there are some parallel lines close to lane lines (barrier line, road cuts) then this pipeline sometimes detect these as road lanes. 
   Possible solution would be to filter on Hue channel to detect yellow lane lines and avoid edges of barrier and road cuts.
